<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>ARENA v6 — Physics + Density</title>
<style>
* { margin: 0; padding: 0; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #06060a; touch-action: none; }
canvas { display: block; width: 100%; height: 100%; }
#hint { position: fixed; bottom: 12%; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.15); font: 11px sans-serif; letter-spacing: 3px; text-transform: uppercase; pointer-events: none; transition: opacity 1s; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">touch · pull · release</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
const hint = document.getElementById('hint');

if (!gl) { document.body.innerHTML = '<p style="color:#fff;padding:40px">WebGL required</p>'; throw 'No WebGL'; }

let W, H, dpr;
function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

const vsSource = `
attribute vec2 aPos;
varying vec2 vUV;
void main() {
  vUV = aPos * 0.5 + 0.5;
  gl_Position = vec4(aPos, 0.0, 1.0);
}`;

// ============================================
// V6: PHYSICS + DENSITY RESTORATION
// Real spring physics in JS, density layers in shader
// ============================================
const fsSource = `
precision highp float;
varying vec2 vUV;

uniform float uTime;
uniform vec2 uResolution;

// Physics state from JS
uniform vec2 uDeformPoint;     // Where deformation is applied
uniform vec2 uDeformVelocity;  // Current velocity of deform point
uniform float uDeformMag;      // Magnitude of deformation
uniform float uTouchActive;
uniform float uSnapped;
uniform vec2 uSnapDir;

#define PI 3.14159265
#define saturate(x) clamp(x, 0.0, 1.0)

// ============================================
// NOISE (Simplex 3D)
// ============================================
vec3 mod289(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;
  i = mod289(i);
  vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
  float n_ = 0.142857142857;
  vec3 ns = n_ * D.wyz - D.xzx;
  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_);
  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}

// FBM for density layers
float fbm(vec3 p, int octaves) {
  float v = 0.0;
  float a = 0.5;
  vec3 shift = vec3(100.0);
  for (int i = 0; i < 5; i++) {
    if (i >= octaves) break;
    v += a * snoise(p);
    p = p * 2.0 + shift;
    a *= 0.5;
  }
  return v;
}

// ============================================
// SMOOTH MINIMUM
// ============================================
float sminSimple(float a, float b, float k) {
  float h = max(k - abs(a - b), 0.0) / k;
  return min(a, b) - h * h * k * 0.25;
}

// ============================================
// PHYSICS-BASED DEFORMATION
// ============================================
vec2 applyDeformation(vec2 p, vec2 center, float radius) {
  vec2 fromCenter = p - center;
  float dist = length(fromCenter);
  
  // Influence falls off with distance from center
  float influence = smoothstep(radius * 1.8, 0.0, dist);
  influence = pow(influence, 1.3); // Sharper falloff
  
  // Direction from center to deform point
  vec2 deformDir = normalize(uDeformPoint - center + 0.001);
  
  // Points aligned with pull direction move more
  float alignment = max(0.0, dot(normalize(fromCenter + 0.001), deformDir));
  float pullInfluence = influence * (0.4 + alignment * 0.6);
  
  // PHYSICS: Deformation based on actual displacement, not position
  vec2 displacement = uDeformPoint - center;
  float deformAmount = length(displacement);
  
  // Apply deformation with velocity-based lag
  // Points further from grab point lag behind (simulates mass)
  float lag = 1.0 - influence * 0.3;
  vec2 deformed = p + deformDir * pullInfluence * uDeformMag * lag * 0.5;
  
  // VOLUME PRESERVATION: Perpendicular bulge
  vec2 perpDir = vec2(-deformDir.y, deformDir.x);
  float perpInfluence = influence * (1.0 - alignment * 0.5);
  float bulge = uDeformMag * 0.15 * perpInfluence;
  float perpDist = dot(fromCenter, perpDir);
  deformed += perpDir * sign(perpDist) * bulge;
  
  // SECONDARY MOTION: Velocity-based wobble
  float velMag = length(uDeformVelocity);
  if (velMag > 0.001) {
    vec2 velDir = uDeformVelocity / velMag;
    // Perpendicular to velocity = wobble direction
    vec2 wobbleDir = vec2(-velDir.y, velDir.x);
    float wobble = sin(dist * 20.0 + uTime * 8.0) * velMag * influence * 0.15;
    deformed += wobbleDir * wobble;
  }
  
  // SNAP RECOIL
  if (uSnapped > 0.01) {
    float snapInfluence = influence * smoothstep(-0.2, 0.8, dot(normalize(fromCenter + 0.001), uSnapDir));
    
    // Primary recoil
    deformed -= uSnapDir * snapInfluence * uSnapped * 0.25;
    
    // Oscillation (overshoot)
    float osc = sin(dist * 30.0 - (1.0 - uSnapped) * 25.0) * uSnapped * 0.04;
    deformed += uSnapDir * osc * snapInfluence;
    
    // Perpendicular jiggle
    vec2 perpSnap = vec2(-uSnapDir.y, uSnapDir.x);
    float jiggle = sin(dist * 35.0 - (1.0 - uSnapped) * 30.0) * uSnapped * 0.025;
    deformed += perpSnap * jiggle * influence;
  }
  
  return deformed;
}

// ============================================
// BLOB SDF WITH ORGANIC EDGE
// ============================================
float sdBlob(vec2 p, vec2 center, float radius) {
  vec2 d = p - center;
  float dist = length(d) - radius;
  
  // Organic wobble on boundary
  float angle = atan(d.y, d.x);
  dist += snoise(vec3(angle * 2.0, length(d) * 5.0, uTime * 0.3)) * 0.025;
  dist += snoise(vec3(angle * 4.0, length(d) * 8.0, uTime * 0.5)) * 0.012;
  
  return dist;
}

// ============================================
// STRAND SDF
// ============================================
float sdStrand(vec2 p, vec2 start, vec2 end, float baseWidth, float tipWidth) {
  vec2 dir = end - start;
  float len = length(dir);
  if (len < 0.01) return 1000.0;
  
  vec2 norm = dir / len;
  float along = dot(p - start, norm);
  float t = clamp(along / len, 0.0, 1.0);
  
  // Variable thickness
  float thickness = mix(baseWidth, tipWidth, pow(t, 0.5));
  
  // Wobble
  vec2 perp = vec2(-norm.y, norm.x);
  float wobble = sin(t * 18.0 + uTime * 3.0) * t * t * 0.008;
  wobble += sin(t * 28.0 + uTime * 4.5) * t * t * 0.004;
  
  vec2 closest = start + norm * along + perp * wobble;
  
  return length(p - closest) - thickness;
}

// ============================================
// LIGHTING
// ============================================
float fresnelSchlick(float cosTheta, float f0) {
  return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);
}

float distributionGGX(float NoH, float roughness) {
  float a = roughness * roughness;
  float a2 = a * a;
  float NoH2 = NoH * NoH;
  float denom = NoH2 * (a2 - 1.0) + 1.0;
  return a2 / (PI * denom * denom + 0.0001);
}

// ============================================
// MAIN
// ============================================
void main() {
  vec2 uv = vUV;
  float aspect = uResolution.x / uResolution.y;
  vec2 p = (uv - 0.5) * vec2(aspect, 1.0);
  
  vec2 center = vec2(0.0, 0.02);
  float baseRadius = 0.32;
  
  // Apply physics-based deformation
  vec2 deformedP = applyDeformation(p, center, baseRadius);
  
  // Main blob SDF
  float d = sdBlob(deformedP, center, baseRadius);
  
  // Strand when pulling
  if (uTouchActive > 0.1 && uDeformMag > 0.08) {
    vec2 strandStart = center + normalize(uDeformPoint - center + 0.001) * baseRadius * 0.7;
    vec2 strandEnd = uDeformPoint;
    float strandD = sdStrand(p, strandStart, strandEnd, 0.045, 0.012);
    d = sminSimple(d, strandD, 0.07);
  }
  
  // Background
  vec3 bgColor = vec3(0.02, 0.025, 0.04);
  bgColor += vec3(0.01, 0.012, 0.025) * (1.0 - length(p) * 0.4);
  
  // Outer glow
  if (d > 0.012) {
    float glowDist = smoothstep(0.18, 0.0, d);
    float tensionGlow = uDeformMag * 0.4;
    vec3 glowColor = vec3(0.04, 0.16, 0.14) * glowDist * (0.3 + tensionGlow);
    gl_FragColor = vec4(bgColor + glowColor, 1.0);
    return;
  }
  
  // ============================================
  // DENSITY LAYERS (the key fix)
  // ============================================
  
  // Depth into blob (0 at edge, 1 at center)
  float rawDepth = -d / baseRadius;
  float depth = smoothstep(0.0, 0.85, rawDepth);
  
  // LAYER 1: Surface (bright, reflective)
  float surfaceLayer = smoothstep(0.0, 0.15, rawDepth) * (1.0 - smoothstep(0.15, 0.35, rawDepth));
  
  // LAYER 2: Subsurface (translucent, colored)
  float subLayer = smoothstep(0.1, 0.4, rawDepth) * (1.0 - smoothstep(0.4, 0.7, rawDepth));
  
  // LAYER 3: Core (dense, dark, pulsing)
  float coreLayer = smoothstep(0.5, 0.9, rawDepth);
  
  // Noise for each layer (different scales)
  float surfaceNoise = fbm(vec3(deformedP * 8.0, uTime * 0.2), 3) * 0.5 + 0.5;
  float subNoise = fbm(vec3(deformedP * 4.0 + 50.0, uTime * 0.15), 4) * 0.5 + 0.5;
  float coreNoise = fbm(vec3(deformedP * 2.0 + 100.0, uTime * 0.1), 3) * 0.5 + 0.5;
  
  // ============================================
  // COLORS PER LAYER
  // ============================================
  
  // Surface colors (lighter, more saturated)
  vec3 surfaceCol1 = vec3(0.08, 0.50, 0.42);
  vec3 surfaceCol2 = vec3(0.12, 0.55, 0.35);
  vec3 surfaceColor = mix(surfaceCol1, surfaceCol2, surfaceNoise);
  
  // Subsurface colors (muted, organic)
  vec3 subCol1 = vec3(0.04, 0.35, 0.32);
  vec3 subCol2 = vec3(0.06, 0.40, 0.28);
  vec3 subCol3 = vec3(0.03, 0.28, 0.38);
  vec3 subColor = mix(mix(subCol1, subCol2, subNoise), subCol3, subNoise * subNoise);
  
  // Core colors (dark, dense)
  vec3 coreCol1 = vec3(0.015, 0.12, 0.14);
  vec3 coreCol2 = vec3(0.02, 0.08, 0.12);
  vec3 coreColor = mix(coreCol1, coreCol2, coreNoise);
  // Core pulse
  float corePulse = sin(uTime * 1.5 + coreNoise * 3.0) * 0.5 + 0.5;
  coreColor += vec3(0.01, 0.04, 0.03) * corePulse;
  
  // Blend layers
  vec3 baseColor = surfaceColor * surfaceLayer +
                   subColor * subLayer +
                   coreColor * coreLayer;
  
  // Fill gaps with interpolation
  float totalWeight = surfaceLayer + subLayer + coreLayer;
  if (totalWeight < 0.3) {
    // Edge region - fade from surface
    baseColor = mix(surfaceColor * 0.8, baseColor, totalWeight / 0.3);
  }
  
  // ============================================
  // DENSITY TEXTURES (veins, cells, inclusions)
  // ============================================
  
  // Veins (worley-like, follows depth)
  float veinNoise = snoise(vec3(deformedP * 12.0, uTime * 0.08));
  float veinNoise2 = snoise(vec3(deformedP * 18.0 + 30.0, uTime * 0.12));
  float veins = smoothstep(0.3, 0.5, abs(veinNoise)) * smoothstep(0.2, 0.5, abs(veinNoise2));
  veins *= subLayer + coreLayer * 0.5; // Veins visible in middle/deep
  baseColor = mix(baseColor, baseColor * 0.7 + vec3(0.01, 0.06, 0.05), veins * 0.4);
  
  // Cellular structures
  float cells = snoise(vec3(deformedP * 25.0, uTime * 0.05));
  float cellEdge = smoothstep(0.0, 0.08, abs(cells - 0.3));
  baseColor = mix(baseColor + vec3(0.02, 0.04, 0.03), baseColor, cellEdge * (1.0 - surfaceLayer));
  
  // Bright inclusions (small, scattered)
  float incl = snoise(vec3(deformedP * 40.0, uTime * 0.3));
  float inclusions = smoothstep(0.85, 0.92, incl) * depth;
  baseColor += vec3(0.15, 0.30, 0.25) * inclusions;
  
  // Dark inclusions (dense spots)
  float darkIncl = snoise(vec3(deformedP * 35.0 + 200.0, uTime * 0.2));
  float darkSpots = smoothstep(0.88, 0.95, darkIncl) * coreLayer;
  baseColor *= (1.0 - darkSpots * 0.5);
  
  // ============================================
  // TENSION COLOR SHIFT
  // ============================================
  float tension = uDeformMag;
  vec3 tensionColor = vec3(0.40, 0.18, 0.06);
  baseColor = mix(baseColor, tensionColor, tension * 0.25 * (1.0 - coreLayer));
  
  // Stretch stress lines
  if (tension > 0.1) {
    vec2 stretchDir = normalize(uDeformPoint - center + 0.001);
    float stretchAlign = abs(dot(normalize(deformedP - center + 0.001), stretchDir));
    float stressLine = sin(stretchAlign * 50.0 + length(deformedP - center) * 30.0) * 0.5 + 0.5;
    stressLine = smoothstep(0.4, 0.6, stressLine) * tension * stretchAlign;
    baseColor = mix(baseColor, tensionColor * 1.2, stressLine * 0.15);
  }
  
  // ============================================
  // NORMALS FROM SDF
  // ============================================
  float eps = 0.004;
  vec2 dp1 = applyDeformation(p + vec2(eps, 0.0), center, baseRadius);
  vec2 dp2 = applyDeformation(p - vec2(eps, 0.0), center, baseRadius);
  vec2 dp3 = applyDeformation(p + vec2(0.0, eps), center, baseRadius);
  vec2 dp4 = applyDeformation(p - vec2(0.0, eps), center, baseRadius);
  float dx = sdBlob(dp1, center, baseRadius) - sdBlob(dp2, center, baseRadius);
  float dy = sdBlob(dp3, center, baseRadius) - sdBlob(dp4, center, baseRadius);
  vec3 normal = normalize(vec3(-dx, -dy, 0.1));
  
  // ============================================
  // LIGHTING
  // ============================================
  vec3 view = vec3(0.0, 0.0, 1.0);
  vec3 light1 = normalize(vec3(0.35, 0.55, 1.0));
  vec3 light2 = normalize(vec3(-0.4, 0.25, 0.7));
  
  float NoV = max(dot(normal, view), 0.001);
  float NoL1 = max(dot(normal, light1), 0.0);
  float NoL2 = max(dot(normal, light2), 0.0);
  
  vec3 H1 = normalize(light1 + view);
  vec3 H2 = normalize(light2 + view);
  float NoH1 = max(dot(normal, H1), 0.0);
  float NoH2 = max(dot(normal, H2), 0.0);
  
  // Diffuse with depth-based absorption
  float diffuse = saturate(NoL1 * 0.5 + NoL2 * 0.25 + 0.2);
  diffuse *= (1.0 - coreLayer * 0.4); // Core absorbs more
  
  // Specular (sharper on surface, softer deep)
  float roughness = 0.3 + depth * 0.25;
  float spec1 = distributionGGX(NoH1, roughness) * NoL1;
  float spec2 = distributionGGX(NoH2, roughness + 0.1) * NoL2;
  float specular = (spec1 * 0.65 + spec2 * 0.35);
  specular *= (1.0 - coreLayer * 0.6); // Less spec in core
  
  // Fresnel (rim light)
  float f0 = 0.04;
  float fresnel = fresnelSchlick(NoV, f0);
  
  // SSS (subsurface scattering)
  vec3 sssColor = vec3(0.06, 0.28, 0.24);
  float sssAmount = subLayer * 0.5 + surfaceLayer * 0.2;
  sssAmount *= (1.0 + subNoise * 0.3);
  vec3 sss = sssColor * sssAmount;
  
  // ============================================
  // COMPOSE
  // ============================================
  vec3 color = baseColor * diffuse;
  color += sss;
  color += vec3(0.90, 0.95, 1.0) * specular * 0.55;
  color += vec3(0.12, 0.22, 0.20) * fresnel * 0.45;
  
  // Surface sheen
  float sheen = pow(NoH1, 12.0) * 0.10 + pow(NoH2, 10.0) * 0.05;
  sheen *= surfaceLayer;
  color += surfaceColor * sheen * 1.8;
  
  gl_FragColor = vec4(color, 1.0);
}`;

// Compile shaders
function createShader(type, source) {
  const s = gl.createShader(type);
  gl.shaderSource(s, source);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    return null;
  }
  return s;
}

const vs = createShader(gl.VERTEX_SHADER, vsSource);
const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
gl.useProgram(prog);

// Fullscreen quad
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'aPos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uTime = gl.getUniformLocation(prog, 'uTime');
const uResolution = gl.getUniformLocation(prog, 'uResolution');
const uDeformPoint = gl.getUniformLocation(prog, 'uDeformPoint');
const uDeformVelocity = gl.getUniformLocation(prog, 'uDeformVelocity');
const uDeformMag = gl.getUniformLocation(prog, 'uDeformMag');
const uTouchActive = gl.getUniformLocation(prog, 'uTouchActive');
const uSnapped = gl.getUniformLocation(prog, 'uSnapped');
const uSnapDir = gl.getUniformLocation(prog, 'uSnapDir');

// ============================================
// PHYSICS STATE
// ============================================
const center = { x: 0.5, y: 0.48 };
const baseRadius = 0.24;

// Spring-mass system for deformation point
const physics = {
  // Current position (where the deform is applied)
  x: 0, y: 0,
  // Velocity
  vx: 0, vy: 0,
  // Target (touch point when active, rest when not)
  targetX: 0, targetY: 0,
  // Rest position (center of blob)
  restX: 0, restY: 0,
  // Spring constants
  stiffness: 12,      // How fast it follows
  damping: 0.75,      // Oscillation decay
  mass: 1.0,
  // State
  active: false,
  magnitude: 0,       // Current stretch amount
  snapped: 0,
  snapDirX: 0,
  snapDirY: 1
};

function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  return {
    x: (clientX - rect.left) / rect.width,
    y: 1 - (clientY - rect.top) / rect.height
  };
}

function toWorld(pos) {
  const aspect = W / H;
  return {
    x: (pos.x - 0.5) * aspect,
    y: pos.y - 0.5
  };
}

function isInBlob(pos) {
  const w = toWorld(pos);
  const cx = (center.x - 0.5) * (W / H);
  const cy = center.y - 0.5;
  const dist = Math.sqrt((w.x - cx) ** 2 + (w.y - cy) ** 2);
  return dist < baseRadius * 1.3;
}

function onStart(e) {
  e.preventDefault();
  const pos = getPos(e);
  if (isInBlob(pos)) {
    const w = toWorld(pos);
    physics.active = true;
    physics.targetX = w.x;
    physics.targetY = w.y;
    // Start at touch point
    physics.x = w.x;
    physics.y = w.y;
    physics.vx = 0;
    physics.vy = 0;
    physics.snapped = 0;
    hint.style.opacity = '0';
  }
}

function onMove(e) {
  if (!physics.active) return;
  e.preventDefault();
  const pos = getPos(e);
  const w = toWorld(pos);
  physics.targetX = w.x;
  physics.targetY = w.y;
}

function onEnd(e) {
  if (!physics.active) return;
  
  if (physics.magnitude > 0.12) {
    // Calculate snap direction from current velocity or position
    const dx = physics.x - physics.restX;
    const dy = physics.y - physics.restY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 0.01) {
      physics.snapDirX = dx / dist;
      physics.snapDirY = dy / dist;
    }
    physics.snapped = 1.0;
  }
  
  physics.active = false;
}

canvas.addEventListener('mousedown', onStart);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onEnd);
canvas.addEventListener('mouseleave', onEnd);
canvas.addEventListener('touchstart', onStart, { passive: false });
canvas.addEventListener('touchmove', onMove, { passive: false });
canvas.addEventListener('touchend', onEnd);
canvas.addEventListener('touchcancel', onEnd);

// ============================================
// PHYSICS UPDATE
// ============================================
let lastTime = performance.now();

function updatePhysics(dt) {
  // Clamp dt to avoid instability
  dt = Math.min(dt, 0.033);
  
  // Rest position is blob center
  const aspect = W / H;
  physics.restX = (center.x - 0.5) * aspect;
  physics.restY = center.y - 0.5;
  
  if (physics.active) {
    // FOLLOW: Spring toward touch target
    const dx = physics.targetX - physics.x;
    const dy = physics.targetY - physics.y;
    
    // Spring force
    const fx = dx * physics.stiffness;
    const fy = dy * physics.stiffness;
    
    // Apply force (F = ma, a = F/m)
    physics.vx += fx * dt;
    physics.vy += fy * dt;
    
    // Damping
    physics.vx *= Math.pow(physics.damping, dt * 60);
    physics.vy *= Math.pow(physics.damping, dt * 60);
    
    // Update position
    physics.x += physics.vx * dt;
    physics.y += physics.vy * dt;
    
  } else {
    // RETURN: Spring back to rest with oscillation
    const dx = physics.restX - physics.x;
    const dy = physics.restY - physics.y;
    
    // Stronger spring for return (snappy)
    const returnStiffness = 25;
    const returnDamping = 0.65; // Less damping = more bounce
    
    const fx = dx * returnStiffness;
    const fy = dy * returnStiffness;
    
    physics.vx += fx * dt;
    physics.vy += fy * dt;
    
    physics.vx *= Math.pow(returnDamping, dt * 60);
    physics.vy *= Math.pow(returnDamping, dt * 60);
    
    physics.x += physics.vx * dt;
    physics.y += physics.vy * dt;
  }
  
  // Calculate magnitude (distance from rest)
  const mx = physics.x - physics.restX;
  const my = physics.y - physics.restY;
  physics.magnitude = Math.sqrt(mx * mx + my * my) * 3.0; // Scale for shader
  physics.magnitude = Math.min(physics.magnitude, 1.0);
  
  // Decay snapped
  if (physics.snapped > 0) {
    physics.snapped *= Math.pow(0.92, dt * 60);
    if (physics.snapped < 0.001) physics.snapped = 0;
  }
}

// ============================================
// RENDER LOOP
// ============================================
let startTime = performance.now();

function render() {
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  
  updatePhysics(dt);
  
  const t = (now - startTime) / 1000;
  
  gl.uniform1f(uTime, t);
  gl.uniform2f(uResolution, canvas.width, canvas.height);
  gl.uniform2f(uDeformPoint, physics.x, physics.y);
  gl.uniform2f(uDeformVelocity, physics.vx, physics.vy);
  gl.uniform1f(uDeformMag, physics.magnitude);
  gl.uniform1f(uTouchActive, physics.active ? 1.0 : 0.0);
  gl.uniform1f(uSnapped, physics.snapped);
  gl.uniform2f(uSnapDir, physics.snapDirX, physics.snapDirY);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
