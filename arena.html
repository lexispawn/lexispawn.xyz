<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>ARENA v11</title>
<style>
* { margin: 0; padding: 0; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #020206; touch-action: none; }
canvas { display: block; width: 100%; height: 100%; }
#hint { position: fixed; bottom: 12%; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.12); font: 11px sans-serif; letter-spacing: 3px; text-transform: uppercase; pointer-events: none; transition: opacity 1s; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">touch · pull · release</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
const hint = document.getElementById('hint');

if (!gl) { document.body.innerHTML = '<p style="color:#fff;padding:40px">WebGL required</p>'; throw 'No WebGL'; }

let W, H, dpr, aspect;
function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth;
  H = window.innerHeight;
  aspect = W / H;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

// ============================================
// PHYSICS - ALL 7 FIXES APPLIED
// ============================================
const NUM_PARTICLES = 32;
const REST_RADIUS = 0.15;
const GRAB_RADIUS = 0.18;        // FIX 1: Larger grab area
const SNAP_DISTANCE = 0.5;

const SPRING_K = 50;
const SPRING_DAMP = 2;
const ANCHOR_BASE = 120;         // Anchor for far particles
const DAMPING_COEFF = 3.0;       // FIX 3: For dt-scaled drag (was 0.9 per frame)
const GRAB_K_BASE = 400;         // FIX 2: Grab WINS (was 25)

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.restX = x;
    this.restY = y;
    this.radius = 0.05 + Math.random() * 0.018;
  }
}

class Spring {
  constructor(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.restLength = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    this.broken = false;
  }
}

const particles = [];
const springs = [];
const centerX = 0;
const centerY = 0.05;

// Snap flash effect
let snapFlashes = []; // {x, y, intensity, time}

function initParticles() {
  particles.push(new Particle(centerX, centerY));
  
  for (let ring = 1; ring <= 3; ring++) {
    const count = 6 + ring * 3;
    const r = REST_RADIUS * (ring / 3.2);
    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2 + ring * 0.2;
      particles.push(new Particle(
        centerX + Math.cos(angle) * r,
        centerY + Math.sin(angle) * r
      ));
    }
  }
  
  while (particles.length < NUM_PARTICLES) {
    const angle = Math.random() * Math.PI * 2;
    const r = Math.random() * REST_RADIUS * 0.85;
    particles.push(new Particle(
      centerX + Math.cos(angle) * r,
      centerY + Math.sin(angle) * r
    ));
  }
  
  particles.forEach(p => { p.restX = p.x; p.restY = p.y; });
  
  for (let i = 0; i < particles.length; i++) {
    for (let j = i + 1; j < particles.length; j++) {
      const dx = particles[i].x - particles[j].x;
      const dy = particles[i].y - particles[j].y;
      if (Math.sqrt(dx * dx + dy * dy) < REST_RADIUS * 0.85) {
        springs.push(new Spring(particles[i], particles[j]));
      }
    }
  }
}

initParticles();

let touchX = 0, touchY = 0;
let grabX = 0, grabY = 0;
let touchActive = false;

function updatePhysics(dt) {
  dt = Math.min(dt, 0.025);
  
  // Spring forces
  for (const spring of springs) {
    if (spring.broken) continue;
    
    const dx = spring.p2.x - spring.p1.x;
    const dy = spring.p2.y - spring.p1.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // FIX 7: SNAP WITH CONSEQUENCE
    if (dist > spring.restLength * (1 + SNAP_DISTANCE)) {
      spring.broken = true;
      
      // Snap impulse - velocity burst away from break point
      const breakX = (spring.p1.x + spring.p2.x) / 2;
      const breakY = (spring.p1.y + spring.p2.y) / 2;
      const impulse = 2.5;
      
      const n1x = (spring.p1.x - breakX);
      const n1y = (spring.p1.y - breakY);
      const n2x = (spring.p2.x - breakX);
      const n2y = (spring.p2.y - breakY);
      const l1 = Math.sqrt(n1x*n1x + n1y*n1y) + 0.001;
      const l2 = Math.sqrt(n2x*n2x + n2y*n2y) + 0.001;
      
      spring.p1.vx += (n1x/l1) * impulse;
      spring.p1.vy += (n1y/l1) * impulse;
      spring.p2.vx += (n2x/l2) * impulse;
      spring.p2.vy += (n2y/l2) * impulse;
      
      // Visual flash
      snapFlashes.push({ x: breakX, y: breakY, intensity: 1.0, birth: performance.now() });
      
      continue;
    }
    
    const stretch = dist - spring.restLength;
    const nx = dx / (dist + 0.0001);
    const ny = dy / (dist + 0.0001);
    
    let fx = SPRING_K * stretch * nx;
    let fy = SPRING_K * stretch * ny;
    
    const dvx = spring.p2.vx - spring.p1.vx;
    const dvy = spring.p2.vy - spring.p1.vy;
    fx += SPRING_DAMP * dvx;
    fy += SPRING_DAMP * dvy;
    
    spring.p1.vx += fx * dt;
    spring.p1.vy += fy * dt;
    spring.p2.vx -= fx * dt;
    spring.p2.vy -= fy * dt;
  }
  
  // Per-particle forces
  for (const p of particles) {
    const dxFromGrab = p.restX - grabX;
    const dyFromGrab = p.restY - grabY;
    const distFromGrab = Math.sqrt(dxFromGrab * dxFromGrab + dyFromGrab * dyFromGrab);
    
    // Displacement from rest (for resistance curve)
    const dispX = p.x - p.restX;
    const dispY = p.y - p.restY;
    const displacement = Math.sqrt(dispX * dispX + dispY * dispY);
    
    if (touchActive && distFromGrab < GRAB_RADIUS * 2.5) {
      // FIX 2: Grabbed particles - anchor is ZERO, grab WINS
      const grabInfluence = 1 - Math.min(distFromGrab / (GRAB_RADIUS * 2.5), 1);
      const grabInfluenceSq = grabInfluence * grabInfluence;
      
      // FIX 4: RESISTANCE CURVE - grab force decreases with stretch
      // Early stretch = easy. Long stretch = harder.
      const resistanceFactor = 1 / (1 + displacement * 4);
      const effectiveGrabK = GRAB_K_BASE * resistanceFactor;
      
      // Grab force toward touch
      const tx = touchX - p.x;
      const ty = touchY - p.y;
      p.vx += tx * effectiveGrabK * grabInfluenceSq * dt;
      p.vy += ty * effectiveGrabK * grabInfluenceSq * dt;
      
      // NO anchor for strongly grabbed particles (anchor scales with inverse of grab influence)
      const anchorStrength = ANCHOR_BASE * (1 - grabInfluenceSq);
      const adx = p.restX - p.x;
      const ady = p.restY - p.y;
      p.vx += adx * anchorStrength * dt;
      p.vy += ady * anchorStrength * dt;
      
    } else {
      // Not grabbed - full anchor
      const adx = p.restX - p.x;
      const ady = p.restY - p.y;
      p.vx += adx * ANCHOR_BASE * dt;
      p.vy += ady * ANCHOR_BASE * dt;
    }
    
    // FIX 3: DT-SCALED DRAG (not per-frame constant)
    // vel *= exp(-damping * dt) instead of vel *= 0.9
    const dragFactor = Math.exp(-DAMPING_COEFF * dt);
    p.vx *= dragFactor;
    p.vy *= dragFactor;
    
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
  
  // Repair springs when close
  if (!touchActive) {
    for (const spring of springs) {
      if (!spring.broken) continue;
      const dx = spring.p2.x - spring.p1.x;
      const dy = spring.p2.y - spring.p1.y;
      if (Math.sqrt(dx * dx + dy * dy) < spring.restLength * 1.15) {
        spring.broken = false;
      }
    }
  }
  
  // Decay snap flashes
  const now = performance.now();
  snapFlashes = snapFlashes.filter(f => now - f.birth < 300);
  for (const f of snapFlashes) {
    f.intensity = 1 - (now - f.birth) / 300;
  }
}

// ============================================
// INPUT
// ============================================
function getWorldPos(e) {
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  return {
    x: ((clientX - rect.left) / rect.width - 0.5) * aspect,
    y: 1 - (clientY - rect.top) / rect.height - 0.5
  };
}

function onStart(e) {
  e.preventDefault();
  const pos = getWorldPos(e);
  
  let inBlob = false;
  for (const p of particles) {
    const dx = p.x - pos.x;
    const dy = p.y - pos.y;
    if (Math.sqrt(dx * dx + dy * dy) < GRAB_RADIUS * 2) {
      inBlob = true;
      break;
    }
  }
  
  if (inBlob) {
    touchX = pos.x;
    touchY = pos.y;
    grabX = pos.x;
    grabY = pos.y;
    touchActive = true;
    hint.style.opacity = '0';
  }
}

function onMove(e) {
  if (!touchActive) return;
  e.preventDefault();
  const pos = getWorldPos(e);
  touchX = pos.x;
  touchY = pos.y;
}

function onEnd(e) {
  touchActive = false;
}

canvas.addEventListener('mousedown', onStart);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onEnd);
canvas.addEventListener('mouseleave', onEnd);
canvas.addEventListener('touchstart', onStart, { passive: false });
canvas.addEventListener('touchmove', onMove, { passive: false });
canvas.addEventListener('touchend', onEnd);
canvas.addEventListener('touchcancel', onEnd);

// ============================================
// FIX 6: GLITTER - FEWER, BRIGHTER, SHARPER
// ============================================
const NUM_GLITTER = 18;
const glitter = [];
for (let i = 0; i < NUM_GLITTER; i++) {
  const angle = Math.random() * Math.PI * 2;
  const r = 0.10 + Math.random() * 0.18;
  glitter.push({
    baseX: Math.cos(angle) * r,
    baseY: Math.sin(angle) * r + 0.05,
    phase: Math.random() * Math.PI * 2,
    speed: 0.3 + Math.random() * 0.8,
    size: 0.012 + Math.random() * 0.008, // Bigger
    brightness: 0.6 + Math.random() * 0.4  // Brighter base
  });
}

// ============================================
// SHADER - FIXES 4, 5, 6 APPLIED
// ============================================
const vsSource = `
attribute vec2 aPos;
varying vec2 vUV;
void main() {
  vUV = aPos * 0.5 + 0.5;
  gl_Position = vec4(aPos, 0.0, 1.0);
}`;

const fsSource = `
precision highp float;
varying vec2 vUV;

uniform float uTime;
uniform vec2 uResolution;
uniform vec3 uParticles[${NUM_PARTICLES}];
uniform vec4 uGlitter[${NUM_GLITTER}];
uniform vec3 uSnapFlashes[8]; // xy = pos, z = intensity

#define PI 3.14159265

float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * (3.0 - 2.0 * f);
  return mix(mix(hash(i), hash(i + vec2(1,0)), f.x),
             mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), f.x), f.y);
}

float fbm(vec2 p) {
  float v = 0.0;
  float a = 0.5;
  for (int i = 0; i < 4; i++) {
    v += a * noise(p);
    p *= 2.0;
    a *= 0.5;
  }
  return v;
}

// FIX 4: SHARPER METABALL - r⁴/(d² + r²)² gives definite skin
float metaball(vec2 p, vec2 c, float r) {
  vec2 d = p - c;
  float d2 = dot(d, d);
  float r2 = r * r;
  // Sharper falloff: quartic numerator, squared denominator
  return (r2 * r2) / ((d2 + r2) * (d2 + r2));
}

float field(vec2 p) {
  float sum = 0.0;
  for (int i = 0; i < ${NUM_PARTICLES}; i++) {
    sum += metaball(p, uParticles[i].xy, uParticles[i].z);
  }
  return sum;
}

vec3 fieldNormal(vec2 p) {
  float eps = 0.002;
  float dx = field(p + vec2(eps, 0)) - field(p - vec2(eps, 0));
  float dy = field(p + vec2(0, eps)) - field(p - vec2(0, eps));
  return normalize(vec3(-dx, -dy, 0.06));
}

void main() {
  float aspect = uResolution.x / uResolution.y;
  vec2 p = (vUV - 0.5) * vec2(aspect, 1.0);
  
  float f = field(p);
  float threshold = 0.08; // Adjusted for new metaball function
  
  vec3 bgColor = vec3(0.006, 0.01, 0.02);
  
  // ============================================
  // SNAP FLASHES
  // ============================================
  float flashSum = 0.0;
  for (int i = 0; i < 8; i++) {
    vec2 fp = uSnapFlashes[i].xy;
    float fi = uSnapFlashes[i].z;
    if (fi > 0.01) {
      float fd = length(p - fp);
      flashSum += fi * 0.02 / (fd * fd + 0.001);
    }
  }
  vec3 flashColor = vec3(0.8, 1.0, 0.95) * flashSum;
  
  // ============================================
  // FIX 6: GLITTER - SHARP PEAKS
  // ============================================
  float glitterSum = 0.0;
  for (int i = 0; i < ${NUM_GLITTER}; i++) {
    vec2 gp = uGlitter[i].xy;
    float gSize = uGlitter[i].z;
    float gBright = uGlitter[i].w;
    
    float d = length(p - gp);
    // Sharp peak falloff - reads as distinct points
    float glow = gBright * pow(max(0.0, 1.0 - d / gSize), 6.0);
    glitterSum += glow;
  }
  // NO 0.15 multiplier - full brightness
  vec3 glitterColor = vec3(0.6, 1.0, 0.9) * glitterSum;
  
  // ============================================
  // GLOW ZONE
  // ============================================
  if (f < threshold) {
    float gNorm = f / threshold;
    
    vec3 glow = vec3(0.0);
    glow += vec3(0.02, 0.10, 0.08) * pow(gNorm, 0.3) * 3.0;
    glow += vec3(0.05, 0.25, 0.20) * pow(gNorm, 1.0) * 2.5;
    glow += vec3(0.10, 0.45, 0.35) * pow(gNorm, 2.5) * 2.0;
    
    glow *= 0.9 + sin(uTime * 1.5) * 0.1;
    
    gl_FragColor = vec4(bgColor + glow + glitterColor + flashColor, 1.0);
    return;
  }
  
  // ============================================
  // FIX 5: INSIDE BLOB - EXAGGERATED LAYER CONTRAST
  // ============================================
  float depth = smoothstep(threshold, threshold * 8.0, f);
  vec3 normal = fieldNormal(p);
  
  // DRAMATIC color separation - think glass marble bands
  vec3 surfaceCol = vec3(0.35, 0.90, 0.75);  // Bright, almost white-green
  vec3 subCol = vec3(0.15, 0.70, 0.60);      // Clear teal
  vec3 midCol = vec3(0.06, 0.50, 0.48);      // Saturated mid
  vec3 deepCol = vec3(0.02, 0.30, 0.35);     // Getting dark
  vec3 coreCol = vec3(0.01, 0.12, 0.18);     // Deep dark core
  
  // Sharper layer transitions (not smooth blends)
  vec3 baseColor = surfaceCol;
  baseColor = mix(baseColor, subCol, smoothstep(0.05, 0.15, depth));
  baseColor = mix(baseColor, midCol, smoothstep(0.12, 0.30, depth));
  baseColor = mix(baseColor, deepCol, smoothstep(0.25, 0.55, depth));
  baseColor = mix(baseColor, coreCol, smoothstep(0.45, 0.85, depth));
  
  // FIX 5: CRANKED UP internal features (3-5x intensity)
  float subPattern = fbm(p * 10.0 + uTime * 0.12);
  baseColor = mix(baseColor, baseColor * 1.5, subPattern * 0.5 * (1.0 - depth));
  
  float veins = fbm(p * 18.0 + vec2(uTime * 0.06, -uTime * 0.09));
  veins = smoothstep(0.35, 0.65, veins);
  baseColor = mix(baseColor, baseColor * 0.5, veins * 0.4 * depth);
  
  // Bright inclusions - VISIBLE
  float incl = noise(p * 45.0 + uTime * 0.6);
  incl = smoothstep(0.82, 0.92, incl) * (1.0 - depth * 0.7);
  baseColor += vec3(0.5, 0.9, 0.8) * incl * 0.8;
  
  // Caustics - CRANKED
  float caustic = noise(p * 25.0 + vec2(sin(uTime * 0.4), cos(uTime * 0.5)) * 0.8);
  caustic = pow(caustic, 2.5) * (1.0 - depth * 0.6);
  baseColor += vec3(0.25, 0.5, 0.45) * caustic * 0.6;
  
  // Lighting
  vec3 L1 = normalize(vec3(0.4, 0.5, 1.0));
  vec3 L2 = normalize(vec3(-0.3, 0.4, 0.8));
  vec3 V = vec3(0.0, 0.0, 1.0);
  
  float diff = max(dot(normal, L1), 0.0) * 0.5 + max(dot(normal, L2), 0.0) * 0.3 + 0.35;
  
  vec3 H = normalize(L1 + V);
  float spec = pow(max(dot(normal, H), 0.0), 50.0) * 1.0 * (1.0 - depth * 0.7);
  
  float NoV = max(dot(normal, V), 0.0);
  float fresnel = pow(1.0 - NoV, 3.5) * 0.8;
  
  vec3 sss = vec3(0.10, 0.40, 0.35) * depth * 0.7;
  
  vec3 color = baseColor * diff;
  color += sss;
  color += vec3(1.0, 1.0, 0.98) * spec;
  color += vec3(0.2, 0.5, 0.45) * fresnel;
  
  // Bright edge rim
  float edge = 1.0 - smoothstep(threshold * 0.9, threshold * 1.5, f);
  color += vec3(0.15, 0.5, 0.42) * edge;
  
  color += glitterColor * 0.5;
  color += flashColor;
  
  gl_FragColor = vec4(color, 1.0);
}`;

function createShader(type, source) {
  const s = gl.createShader(type);
  gl.shaderSource(s, source);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    return null;
  }
  return s;
}

const vs = createShader(gl.VERTEX_SHADER, vsSource);
const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
if (!vs || !fs) throw 'Shader error';

const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'aPos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

const uTime = gl.getUniformLocation(prog, 'uTime');
const uResolution = gl.getUniformLocation(prog, 'uResolution');
const uParticles = gl.getUniformLocation(prog, 'uParticles');
const uGlitter = gl.getUniformLocation(prog, 'uGlitter');
const uSnapFlashes = gl.getUniformLocation(prog, 'uSnapFlashes');

let lastTime = performance.now();
let startTime = lastTime;

function render() {
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  const t = (now - startTime) / 1000;
  
  updatePhysics(dt);
  
  const particleData = new Float32Array(NUM_PARTICLES * 3);
  for (let i = 0; i < particles.length && i < NUM_PARTICLES; i++) {
    particleData[i * 3] = particles[i].x;
    particleData[i * 3 + 1] = particles[i].y;
    particleData[i * 3 + 2] = particles[i].radius;
  }
  
  const glitterData = new Float32Array(NUM_GLITTER * 4);
  for (let i = 0; i < NUM_GLITTER; i++) {
    const g = glitter[i];
    const orbitR = 0.015;
    const ox = Math.sin(t * g.speed + g.phase) * orbitR;
    const oy = Math.cos(t * g.speed * 0.7 + g.phase) * orbitR;
    glitterData[i * 4] = g.baseX + ox;
    glitterData[i * 4 + 1] = g.baseY + oy;
    glitterData[i * 4 + 2] = g.size;
    // Sharp twinkle - on/off more than smooth
    const twinkle = Math.pow(Math.sin(t * g.speed * 4 + g.phase * 3) * 0.5 + 0.5, 3.0);
    glitterData[i * 4 + 3] = g.brightness * (0.3 + twinkle * 0.7);
  }
  
  // Pack snap flashes
  const flashData = new Float32Array(8 * 3);
  for (let i = 0; i < 8; i++) {
    if (i < snapFlashes.length) {
      flashData[i * 3] = snapFlashes[i].x;
      flashData[i * 3 + 1] = snapFlashes[i].y;
      flashData[i * 3 + 2] = snapFlashes[i].intensity;
    } else {
      flashData[i * 3 + 2] = 0;
    }
  }
  
  gl.uniform1f(uTime, t);
  gl.uniform2f(uResolution, canvas.width, canvas.height);
  gl.uniform3fv(uParticles, particleData);
  gl.uniform4fv(uGlitter, glitterData);
  gl.uniform3fv(uSnapFlashes, flashData);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
