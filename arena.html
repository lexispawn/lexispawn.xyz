<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>ARENA v7 — Particle Metaballs</title>
<style>
* { margin: 0; padding: 0; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #050508; touch-action: none; }
canvas { display: block; width: 100%; height: 100%; }
#hint { position: fixed; bottom: 12%; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.15); font: 11px sans-serif; letter-spacing: 3px; text-transform: uppercase; pointer-events: none; transition: opacity 1s; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">touch · pull · release</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
const hint = document.getElementById('hint');

if (!gl) { document.body.innerHTML = '<p style="color:#fff;padding:40px">WebGL required</p>'; throw 'No WebGL'; }

let W, H, dpr, aspect;
function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth;
  H = window.innerHeight;
  aspect = W / H;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

// ============================================
// PARTICLE SYSTEM (JS)
// ============================================
const NUM_PARTICLES = 25;
const REST_RADIUS = 0.12; // How tightly packed at rest
const PARTICLE_MASS = 1.0;
const SPRING_STIFFNESS = 180;
const SPRING_DAMPING = 12;
const GRAB_RADIUS = 0.15;
const SNAP_DISTANCE = 0.4; // When springs break

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.restX = x;
    this.restY = y;
    this.grabbed = false;
    this.radius = 0.08 + Math.random() * 0.03; // Metaball radius
  }
}

class Spring {
  constructor(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.restLength = Math.sqrt(
      (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2
    );
    this.broken = false;
  }
}

// Initialize particles in a blob shape
const particles = [];
const springs = [];
const centerX = 0;
const centerY = 0.05;

// Create particles in concentric rings
function initParticles() {
  // Center particle
  particles.push(new Particle(centerX, centerY));
  
  // Inner ring
  const innerCount = 6;
  for (let i = 0; i < innerCount; i++) {
    const angle = (i / innerCount) * Math.PI * 2;
    const r = REST_RADIUS * 0.5;
    particles.push(new Particle(
      centerX + Math.cos(angle) * r,
      centerY + Math.sin(angle) * r
    ));
  }
  
  // Outer ring
  const outerCount = 12;
  for (let i = 0; i < outerCount; i++) {
    const angle = (i / outerCount) * Math.PI * 2 + 0.15;
    const r = REST_RADIUS;
    particles.push(new Particle(
      centerX + Math.cos(angle) * r,
      centerY + Math.sin(angle) * r
    ));
  }
  
  // Additional scattered particles
  while (particles.length < NUM_PARTICLES) {
    const angle = Math.random() * Math.PI * 2;
    const r = Math.random() * REST_RADIUS * 0.8;
    particles.push(new Particle(
      centerX + Math.cos(angle) * r,
      centerY + Math.sin(angle) * r
    ));
  }
  
  // Store rest positions
  particles.forEach(p => {
    p.restX = p.x;
    p.restY = p.y;
  });
  
  // Create springs between nearby particles
  for (let i = 0; i < particles.length; i++) {
    for (let j = i + 1; j < particles.length; j++) {
      const dx = particles[i].x - particles[j].x;
      const dy = particles[i].y - particles[j].y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      // Connect particles that are close enough
      if (dist < REST_RADIUS * 1.2) {
        springs.push(new Spring(particles[i], particles[j]));
      }
    }
  }
}

initParticles();

// Physics state
let grabbedParticles = [];
let touchX = 0, touchY = 0;
let touchActive = false;

function updatePhysics(dt) {
  dt = Math.min(dt, 0.02); // Cap for stability
  
  // Apply spring forces
  for (const spring of springs) {
    if (spring.broken) continue;
    
    const dx = spring.p2.x - spring.p1.x;
    const dy = spring.p2.y - spring.p1.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // Check for snap
    if (dist > spring.restLength * (1 + SNAP_DISTANCE)) {
      spring.broken = true;
      continue;
    }
    
    const stretch = dist - spring.restLength;
    const nx = dx / (dist + 0.0001);
    const ny = dy / (dist + 0.0001);
    
    // Spring force (Hooke's law)
    const fx = SPRING_STIFFNESS * stretch * nx;
    const fy = SPRING_STIFFNESS * stretch * ny;
    
    // Relative velocity for damping
    const dvx = spring.p2.vx - spring.p1.vx;
    const dvy = spring.p2.vy - spring.p1.vy;
    const dampX = SPRING_DAMPING * dvx;
    const dampY = SPRING_DAMPING * dvy;
    
    if (!spring.p1.grabbed) {
      spring.p1.vx += (fx + dampX) * dt / PARTICLE_MASS;
      spring.p1.vy += (fy + dampY) * dt / PARTICLE_MASS;
    }
    if (!spring.p2.grabbed) {
      spring.p2.vx -= (fx + dampX) * dt / PARTICLE_MASS;
      spring.p2.vy -= (fy + dampY) * dt / PARTICLE_MASS;
    }
  }
  
  // Restore force toward rest position (keeps blob cohesive)
  const restoreStrength = 15;
  for (const p of particles) {
    if (p.grabbed) continue;
    
    const dx = p.restX - p.x;
    const dy = p.restY - p.y;
    p.vx += dx * restoreStrength * dt;
    p.vy += dy * restoreStrength * dt;
  }
  
  // Grabbed particles follow touch with spring
  if (touchActive && grabbedParticles.length > 0) {
    const grabStiffness = 25;
    const grabDamp = 8;
    for (const p of grabbedParticles) {
      const dx = touchX - p.x;
      const dy = touchY - p.y;
      p.vx += dx * grabStiffness * dt;
      p.vy += dy * grabStiffness * dt;
      p.vx *= (1 - grabDamp * dt);
      p.vy *= (1 - grabDamp * dt);
    }
  }
  
  // Update positions
  for (const p of particles) {
    // General damping
    p.vx *= 0.98;
    p.vy *= 0.98;
    
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
  
  // Repair broken springs when particles are close again (snap back)
  if (!touchActive) {
    for (const spring of springs) {
      if (!spring.broken) continue;
      const dx = spring.p2.x - spring.p1.x;
      const dy = spring.p2.y - spring.p1.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < spring.restLength * 1.3) {
        spring.broken = false;
      }
    }
  }
}

// ============================================
// INPUT
// ============================================
function getWorldPos(e) {
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  const nx = (clientX - rect.left) / rect.width;
  const ny = 1 - (clientY - rect.top) / rect.height;
  return {
    x: (nx - 0.5) * aspect,
    y: ny - 0.5
  };
}

function onStart(e) {
  e.preventDefault();
  const pos = getWorldPos(e);
  touchX = pos.x;
  touchY = pos.y;
  
  // Find particles near touch
  grabbedParticles = [];
  for (const p of particles) {
    const dx = p.x - pos.x;
    const dy = p.y - pos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < GRAB_RADIUS) {
      p.grabbed = true;
      grabbedParticles.push(p);
    }
  }
  
  if (grabbedParticles.length > 0) {
    touchActive = true;
    hint.style.opacity = '0';
  }
}

function onMove(e) {
  if (!touchActive) return;
  e.preventDefault();
  const pos = getWorldPos(e);
  touchX = pos.x;
  touchY = pos.y;
}

function onEnd(e) {
  touchActive = false;
  for (const p of particles) {
    p.grabbed = false;
  }
  grabbedParticles = [];
}

canvas.addEventListener('mousedown', onStart);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onEnd);
canvas.addEventListener('mouseleave', onEnd);
canvas.addEventListener('touchstart', onStart, { passive: false });
canvas.addEventListener('touchmove', onMove, { passive: false });
canvas.addEventListener('touchend', onEnd);
canvas.addEventListener('touchcancel', onEnd);

// ============================================
// SHADER (Metaball Rendering)
// ============================================
const vsSource = `
attribute vec2 aPos;
varying vec2 vUV;
void main() {
  vUV = aPos * 0.5 + 0.5;
  gl_Position = vec4(aPos, 0.0, 1.0);
}`;

const fsSource = `
precision highp float;
varying vec2 vUV;

uniform float uTime;
uniform vec2 uResolution;
uniform vec3 uParticles[${NUM_PARTICLES}]; // xy = position, z = radius

#define PI 3.14159265

// Metaball field function
float metaball(vec2 p, vec2 center, float radius) {
  float r2 = radius * radius;
  vec2 d = p - center;
  float d2 = dot(d, d);
  // Smooth falloff: r²/(r² + d²) gives 1 at center, falls to 0
  return r2 / (d2 + r2 * 0.1);
}

// Sum all metaball contributions
float field(vec2 p) {
  float sum = 0.0;
  for (int i = 0; i < ${NUM_PARTICLES}; i++) {
    sum += metaball(p, uParticles[i].xy, uParticles[i].z);
  }
  return sum;
}

// Numerical gradient for normals
vec3 fieldNormal(vec2 p) {
  float eps = 0.005;
  float dx = field(p + vec2(eps, 0.0)) - field(p - vec2(eps, 0.0));
  float dy = field(p + vec2(0.0, eps)) - field(p - vec2(0.0, eps));
  return normalize(vec3(-dx, -dy, 0.15));
}

void main() {
  vec2 uv = vUV;
  float aspect = uResolution.x / uResolution.y;
  vec2 p = (uv - 0.5) * vec2(aspect, 1.0);
  
  // Compute metaball field
  float f = field(p);
  
  // Threshold for surface
  float threshold = 1.8;
  
  // Background
  vec3 bgColor = vec3(0.02, 0.025, 0.04);
  bgColor += vec3(0.008, 0.01, 0.02) * (1.0 - length(p) * 0.5);
  
  // Outside blob
  if (f < threshold * 0.7) {
    // Glow
    float glow = smoothstep(threshold * 0.3, threshold * 0.7, f);
    vec3 glowColor = vec3(0.03, 0.12, 0.10) * glow * 0.5;
    gl_FragColor = vec4(bgColor + glowColor, 1.0);
    return;
  }
  
  // Inside blob - compute depth and normal
  float depth = smoothstep(threshold, threshold * 3.0, f);
  vec3 normal = fieldNormal(p);
  
  // Base color with depth variation
  vec3 surfaceColor = vec3(0.06, 0.45, 0.38);
  vec3 midColor = vec3(0.04, 0.35, 0.30);
  vec3 coreColor = vec3(0.02, 0.15, 0.18);
  
  vec3 baseColor = mix(surfaceColor, midColor, depth * 0.6);
  baseColor = mix(baseColor, coreColor, depth * depth);
  
  // Add some noise variation
  float noise = sin(p.x * 25.0 + uTime * 0.5) * sin(p.y * 25.0 + uTime * 0.3) * 0.5 + 0.5;
  baseColor = mix(baseColor, baseColor * 1.1, noise * 0.15 * (1.0 - depth));
  
  // Lighting
  vec3 light1 = normalize(vec3(0.4, 0.5, 1.0));
  vec3 light2 = normalize(vec3(-0.3, 0.3, 0.8));
  vec3 view = vec3(0.0, 0.0, 1.0);
  
  float diff1 = max(dot(normal, light1), 0.0);
  float diff2 = max(dot(normal, light2), 0.0);
  float diffuse = diff1 * 0.6 + diff2 * 0.3 + 0.2;
  
  // Specular
  vec3 h1 = normalize(light1 + view);
  vec3 h2 = normalize(light2 + view);
  float spec1 = pow(max(dot(normal, h1), 0.0), 20.0);
  float spec2 = pow(max(dot(normal, h2), 0.0), 15.0);
  float specular = spec1 * 0.5 + spec2 * 0.25;
  specular *= (1.0 - depth * 0.5); // Less spec in core
  
  // Fresnel rim
  float NoV = max(dot(normal, view), 0.0);
  float fresnel = pow(1.0 - NoV, 4.0) * 0.4;
  
  // Subsurface scattering approximation
  vec3 sssColor = vec3(0.05, 0.25, 0.22);
  float sss = depth * 0.4 * (1.0 + noise * 0.2);
  
  // Compose
  vec3 color = baseColor * diffuse;
  color += sssColor * sss;
  color += vec3(0.9, 0.95, 1.0) * specular * 0.5;
  color += vec3(0.1, 0.2, 0.18) * fresnel;
  
  // Edge softness
  float edge = smoothstep(threshold * 0.7, threshold, f);
  color = mix(bgColor, color, edge);
  
  gl_FragColor = vec4(color, 1.0);
}`;

// Compile shaders
function createShader(type, source) {
  const s = gl.createShader(type);
  gl.shaderSource(s, source);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(s));
    return null;
  }
  return s;
}

const vs = createShader(gl.VERTEX_SHADER, vsSource);
const fs = createShader(gl.FRAGMENT_SHADER, fsSource);

if (!vs || !fs) {
  document.body.innerHTML = '<p style="color:#fff;padding:40px">Shader compile failed</p>';
  throw 'Shader error';
}

const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);

if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
  console.error('Link error:', gl.getProgramInfoLog(prog));
  throw 'Link error';
}

gl.useProgram(prog);

// Fullscreen quad
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'aPos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uTime = gl.getUniformLocation(prog, 'uTime');
const uResolution = gl.getUniformLocation(prog, 'uResolution');
const uParticles = gl.getUniformLocation(prog, 'uParticles');

// ============================================
// RENDER LOOP
// ============================================
let lastTime = performance.now();
let startTime = lastTime;

function render() {
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  
  // Update physics
  updatePhysics(dt);
  
  // Pack particle data for shader
  const particleData = new Float32Array(NUM_PARTICLES * 3);
  for (let i = 0; i < particles.length; i++) {
    particleData[i * 3 + 0] = particles[i].x;
    particleData[i * 3 + 1] = particles[i].y;
    particleData[i * 3 + 2] = particles[i].radius;
  }
  
  const t = (now - startTime) / 1000;
  
  gl.uniform1f(uTime, t);
  gl.uniform2f(uResolution, canvas.width, canvas.height);
  gl.uniform3fv(uParticles, particleData);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
