<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Slime Minimal</title>
<style>
* { margin: 0; padding: 0; }
body { background: #111; overflow: hidden; touch-action: none; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Simple particles
const particles = [];
const springs = [];
const cx = 0.5, cy = 0.5; // center in normalized coords

// Create blob - fewer particles for stability
const numRings = 2;
const restRadius = 0.08;

particles.push({ x: cx, y: cy, vx: 0, vy: 0, restX: cx, restY: cy });

for (let ring = 1; ring <= numRings; ring++) {
  const count = 6 * ring;
  const r = restRadius * (ring / numRings);
  for (let i = 0; i < count; i++) {
    const a = (i / count) * Math.PI * 2;
    const px = cx + Math.cos(a) * r;
    const py = cy + Math.sin(a) * r;
    particles.push({ x: px, y: py, vx: 0, vy: 0, restX: px, restY: py });
  }
}

// Connect nearby particles
for (let i = 0; i < particles.length; i++) {
  for (let j = i + 1; j < particles.length; j++) {
    const dx = particles[i].x - particles[j].x;
    const dy = particles[i].y - particles[j].y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d < restRadius * 0.8) {
      springs.push({
        a: particles[i],
        b: particles[j],
        rest: d,
        broken: false
      });
    }
  }
}

// Physics constants - VERY CONSERVATIVE
const springK = 800;
const springDamp = 20;
const anchorK = 100;    // Pull back to rest
const grabK = 300;      // Follow touch
const grabRadius = 0.12;
const drag = 0.92;
const snapDist = 0.6;   // 60% stretch = snap

let touchX = 0, touchY = 0;
let touching = false;
let grabPoint = { x: 0, y: 0 };

function toWorld(clientX, clientY) {
  return {
    x: clientX / canvas.width,
    y: clientY / canvas.height
  };
}

canvas.addEventListener('mousedown', e => {
  const p = toWorld(e.clientX, e.clientY);
  touchX = p.x; touchY = p.y;
  grabPoint.x = p.x; grabPoint.y = p.y;
  touching = true;
});
canvas.addEventListener('mousemove', e => {
  if (!touching) return;
  const p = toWorld(e.clientX, e.clientY);
  touchX = p.x; touchY = p.y;
});
canvas.addEventListener('mouseup', () => { touching = false; });
canvas.addEventListener('mouseleave', () => { touching = false; });

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  const p = toWorld(t.clientX, t.clientY);
  touchX = p.x; touchY = p.y;
  grabPoint.x = p.x; grabPoint.y = p.y;
  touching = true;
}, { passive: false });
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (!touching) return;
  const t = e.touches[0];
  const p = toWorld(t.clientX, t.clientY);
  touchX = p.x; touchY = p.y;
}, { passive: false });
canvas.addEventListener('touchend', () => { touching = false; });
canvas.addEventListener('touchcancel', () => { touching = false; });

let lastTime = performance.now();

function update() {
  const now = performance.now();
  let dt = (now - lastTime) / 1000;
  lastTime = now;
  dt = Math.min(dt, 0.02); // Cap dt
  
  // Spring forces
  for (const s of springs) {
    if (s.broken) continue;
    
    const dx = s.b.x - s.a.x;
    const dy = s.b.y - s.a.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    
    // Snap check
    if (d > s.rest * (1 + snapDist)) {
      s.broken = true;
      // Small impulse
      const nx = dx / d, ny = dy / d;
      s.a.vx -= nx * 0.5;
      s.a.vy -= ny * 0.5;
      s.b.vx += nx * 0.5;
      s.b.vy += ny * 0.5;
      continue;
    }
    
    const stretch = d - s.rest;
    const nx = dx / (d + 0.0001);
    const ny = dy / (d + 0.0001);
    
    // Spring force
    const fx = springK * stretch * nx * dt;
    const fy = springK * stretch * ny * dt;
    
    // Damping
    const dvx = s.b.vx - s.a.vx;
    const dvy = s.b.vy - s.a.vy;
    const dampX = springDamp * dvx * dt;
    const dampY = springDamp * dvy * dt;
    
    s.a.vx += fx + dampX;
    s.a.vy += fy + dampY;
    s.b.vx -= fx + dampX;
    s.b.vy -= fy + dampY;
  }
  
  // Per particle
  for (const p of particles) {
    // Distance from grab point (for anchor strength)
    const dgx = p.restX - grabPoint.x;
    const dgy = p.restY - grabPoint.y;
    const distFromGrab = Math.sqrt(dgx*dgx + dgy*dgy);
    
    // Anchor - stronger when far from grab
    const anchorStrength = touching ? 
      anchorK * Math.min(distFromGrab / 0.15, 1) : // Near grab = weak anchor
      anchorK; // Not touching = full anchor
    
    const ax = (p.restX - p.x) * anchorStrength * dt;
    const ay = (p.restY - p.y) * anchorStrength * dt;
    p.vx += ax;
    p.vy += ay;
    
    // Grab - pull toward touch
    if (touching) {
      const dtx = p.x - touchX;
      const dty = p.y - touchY;
      const distToTouch = Math.sqrt(dtx*dtx + dty*dty);
      
      if (distToTouch < grabRadius) {
        const influence = 1 - (distToTouch / grabRadius);
        const gx = (touchX - p.x) * grabK * influence * dt;
        const gy = (touchY - p.y) * grabK * influence * dt;
        p.vx += gx;
        p.vy += gy;
      }
    }
    
    // Drag
    p.vx *= drag;
    p.vy *= drag;
    
    // Integrate
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
  
  // Repair springs when close
  if (!touching) {
    for (const s of springs) {
      if (!s.broken) continue;
      const dx = s.b.x - s.a.x;
      const dy = s.b.y - s.a.y;
      if (Math.sqrt(dx*dx + dy*dy) < s.rest * 1.1) {
        s.broken = false;
      }
    }
  }
}

function draw() {
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  const w = canvas.width, h = canvas.height;
  
  // Draw springs
  ctx.strokeStyle = 'rgba(100, 200, 180, 0.3)';
  ctx.lineWidth = 2;
  for (const s of springs) {
    if (s.broken) continue;
    ctx.beginPath();
    ctx.moveTo(s.a.x * w, s.a.y * h);
    ctx.lineTo(s.b.x * w, s.b.y * h);
    ctx.stroke();
  }
  
  // Draw particles
  ctx.fillStyle = 'rgba(100, 220, 180, 0.8)';
  for (const p of particles) {
    ctx.beginPath();
    ctx.arc(p.x * w, p.y * h, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Draw touch point
  if (touching) {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(touchX * w, touchY * h, grabRadius * w, 0, Math.PI * 2);
    ctx.stroke();
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
