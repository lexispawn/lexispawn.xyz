<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ARENA</title>
<style>*{margin:0;padding:0}body{background:#020206;overflow:hidden;touch-action:none}canvas{display:block}</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true });

let W, H, aspect;
function resize() {
  W = innerWidth; H = innerHeight; aspect = W / H;
  canvas.width = W * Math.min(devicePixelRatio, 2);
  canvas.height = H * Math.min(devicePixelRatio, 2);
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
addEventListener('resize', resize);

// ========== PHYSICS (0-1 coordinate space, same as working minimal) ==========
const particles = [];
const springs = [];
const cx = 0.5, cy = 0.5, restRadius = 0.08;

// Physics constants - PROVEN TO WORK
const springK = 100, springDamp = 5;
const anchorFar = 70, anchorNear = 0, anchorFalloff = 0.05;
const grabKBase = 220, grabRadius = 0.10;
const drag = 0.95, snapDist = 0.6, maxVel = 0.4;

// Create particles
particles.push({ x: cx, y: cy, vx: 0, vy: 0, restX: cx, restY: cy, snapped: false, r: 0.025 });
for (let ring = 1; ring <= 2; ring++) {
  const count = 6 * ring;
  for (let i = 0; i < count; i++) {
    const a = (i / count) * Math.PI * 2 + ring * 0.2;
    const r = restRadius * (ring / 2);
    const px = cx + Math.cos(a) * r, py = cy + Math.sin(a) * r;
    particles.push({ x: px, y: py, vx: 0, vy: 0, restX: px, restY: py, snapped: false, r: 0.018 + Math.random() * 0.008 });
  }
}
const NUM_P = particles.length;

// Create springs
for (let i = 0; i < NUM_P; i++) {
  for (let j = i + 1; j < NUM_P; j++) {
    const dx = particles[i].x - particles[j].x, dy = particles[i].y - particles[j].y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d < restRadius * 0.75) springs.push({ a: particles[i], b: particles[j], rest: d, broken: false });
  }
}

let touchX = 0.5, touchY = 0.5, grabX = 0.5, grabY = 0.5, touching = false;
let snapFlashes = [];

function toNorm(cX, cY) { return { x: cX / W, y: cY / H }; }

canvas.onmousedown = e => { const p = toNorm(e.clientX, e.clientY); touchX = grabX = p.x; touchY = grabY = p.y; touching = true; };
canvas.onmousemove = e => { if (touching) { const p = toNorm(e.clientX, e.clientY); touchX = p.x; touchY = p.y; } };
canvas.onmouseup = canvas.onmouseleave = () => { touching = false; };
canvas.ontouchstart = e => { e.preventDefault(); const t = e.touches[0], p = toNorm(t.clientX, t.clientY); touchX = grabX = p.x; touchY = grabY = p.y; touching = true; };
canvas.ontouchmove = e => { e.preventDefault(); if (touching) { const t = e.touches[0], p = toNorm(t.clientX, t.clientY); touchX = p.x; touchY = p.y; } };
canvas.ontouchend = canvas.ontouchcancel = () => { touching = false; };

function physics(dt) {
  dt = Math.min(dt, 0.02);
  const now = performance.now();
  
  for (const s of springs) {
    if (s.broken) continue;
    const dx = s.b.x - s.a.x, dy = s.b.y - s.a.y, d = Math.sqrt(dx*dx + dy*dy);
    if (d > s.rest * (1 + snapDist)) {
      s.broken = true; s.a.snapped = s.b.snapped = true;
      const nx = dx/d, ny = dy/d;
      s.a.vx -= nx * 0.5; s.a.vy -= ny * 0.5;
      s.b.vx += nx * 0.5; s.b.vy += ny * 0.5;
      snapFlashes.push({ x: (s.a.x + s.b.x) / 2, y: (s.a.y + s.b.y) / 2, t: now });
      continue;
    }
    const stretch = d - s.rest, nx = dx / (d + 1e-6), ny = dy / (d + 1e-6);
    const fx = springK * stretch * nx * dt, fy = springK * stretch * ny * dt;
    const dvx = s.b.vx - s.a.vx, dvy = s.b.vy - s.a.vy;
    s.a.vx += fx + springDamp * dvx * dt; s.a.vy += fy + springDamp * dvy * dt;
    s.b.vx -= fx + springDamp * dvx * dt; s.b.vy -= fy + springDamp * dvy * dt;
  }
  
  for (const p of particles) {
    const dgx = p.restX - grabX, dgy = p.restY - grabY, dg = Math.sqrt(dgx*dgx + dgy*dgy);
    let anchor = p.snapped ? 8 : (touching ? anchorNear + (anchorFar - anchorNear) * Math.pow(Math.min(dg / anchorFalloff, 1), 2) : anchorFar * 0.5);
    p.vx += (p.restX - p.x) * anchor * dt;
    p.vy += (p.restY - p.y) * anchor * dt;
    
    if (touching) {
      const dtx = p.x - touchX, dty = p.y - touchY, dt2 = Math.sqrt(dtx*dtx + dty*dty);
      if (dt2 < grabRadius) {
        const sx = p.x - p.restX, sy = p.y - p.restY, sd = Math.sqrt(sx*sx + sy*sy);
        const gk = grabKBase / (1 + sd * 8) * (1 - dt2 / grabRadius);
        p.vx += (touchX - p.x) * gk * dt;
        p.vy += (touchY - p.y) * gk * dt;
      }
    }
    
    p.vx *= drag; p.vy *= drag;
    const v = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
    if (v > maxVel) { p.vx *= maxVel/v; p.vy *= maxVel/v; }
    p.x += p.vx * dt; p.y += p.vy * dt;
  }
  
  if (!touching) for (const s of springs) {
    if (!s.broken) continue;
    const dx = s.b.x - s.a.x, dy = s.b.y - s.a.y;
    if (Math.sqrt(dx*dx + dy*dy) < s.rest * 1.1) { s.broken = false; s.a.snapped = s.b.snapped = false; }
  }
  
  snapFlashes = snapFlashes.filter(f => now - f.t < 300);
}

// ========== SHADER ==========
const vs = `attribute vec2 p;varying vec2 uv;void main(){uv=p*.5+.5;gl_Position=vec4(p,0,1);}`;
const fs = `
precision highp float;
varying vec2 uv;
uniform float time;
uniform vec2 res;
uniform vec3 parts[${NUM_P}];
uniform vec3 flash[8];

float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
float noise(vec2 p){vec2 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);return mix(mix(hash(i),hash(i+vec2(1,0)),f.x),mix(hash(i+vec2(0,1)),hash(i+vec2(1,1)),f.x),f.y);}
float fbm(vec2 p){float v=0.,a=.5;for(int i=0;i<4;i++){v+=a*noise(p);p*=2.;a*=.5;}return v;}

float blob(vec2 p,vec2 c,float r){vec2 d=p-c;float q=dot(d,d),r2=r*r;return r2*r2/((q+r2)*(q+r2));}

float field(vec2 p){float s=0.;for(int i=0;i<${NUM_P};i++)s+=blob(p,parts[i].xy,parts[i].z);return s;}

vec3 norm(vec2 p){float e=.002;return normalize(vec3(field(p-vec2(e,0))-field(p+vec2(e,0)),field(p-vec2(0,e))-field(p+vec2(0,e)),.06));}

void main(){
  vec2 p=uv;
  float asp=res.x/res.y;
  vec2 cp=(p-.5)*vec2(asp,1.);
  
  // Convert particle coords to aspect-corrected for rendering
  float f=0.;
  for(int i=0;i<${NUM_P};i++){
    vec2 pc=(parts[i].xy-.5)*vec2(asp,1.);
    f+=blob(cp,pc,parts[i].z*asp);
  }
  
  float th=.06;
  vec3 bg=vec3(.006,.012,.025);
  
  // Flashes
  float fl=0.;
  for(int i=0;i<8;i++){
    vec2 fc=(flash[i].xy-.5)*vec2(asp,1.);
    if(flash[i].z>.01)fl+=flash[i].z*.015/(dot(cp-fc,cp-fc)+.0005);
  }
  vec3 flashC=vec3(.9,1.,.95)*fl;
  
  if(f<th){
    float g=f/th;
    vec3 glow=vec3(.02,.12,.1)*pow(g,.3)*3.+vec3(.06,.28,.22)*pow(g,1.2)*2.+vec3(.12,.5,.4)*pow(g,2.5)*1.5;
    glow*=.92+sin(time*1.8)*.08;
    gl_FragColor=vec4(bg+glow+flashC,1.);
    return;
  }
  
  float depth=smoothstep(th,th*6.,f);
  
  vec2 np=(p-.5)*vec2(asp,1.);
  float e=.002;
  float fx=0.,fy=0.;
  for(int i=0;i<${NUM_P};i++){
    vec2 pc=(parts[i].xy-.5)*vec2(asp,1.);
    fx+=blob(np-vec2(e,0),pc,parts[i].z*asp)-blob(np+vec2(e,0),pc,parts[i].z*asp);
    fy+=blob(np-vec2(0,e),pc,parts[i].z*asp)-blob(np+vec2(0,e),pc,parts[i].z*asp);
  }
  vec3 n=normalize(vec3(fx,fy,.05));
  
  vec3 col=vec3(.38,.92,.78);
  col=mix(col,vec3(.18,.72,.62),smoothstep(.05,.18,depth));
  col=mix(col,vec3(.08,.52,.5),smoothstep(.15,.35,depth));
  col=mix(col,vec3(.03,.32,.38),smoothstep(.3,.6,depth));
  col=mix(col,vec3(.015,.15,.22),smoothstep(.5,.9,depth));
  
  col=mix(col,col*1.4,fbm(np*12.+time*.15)*.45*(1.-depth));
  col+=vec3(.4,.85,.75)*smoothstep(.83,.93,noise(np*50.+time*.7))*(1.-depth*.6)*.7;
  
  vec3 L=normalize(vec3(.4,.5,1.)),V=vec3(0,0,1);
  float diff=max(dot(n,L),0.)*.55+max(dot(n,normalize(vec3(-.3,.4,.8))),0.)*.25+.3;
  float spec=pow(max(dot(n,normalize(L+V)),0.),45.)*(1.-depth*.6);
  float fres=pow(1.-max(dot(n,V),0.),3.5)*.75;
  
  vec3 c=col*diff+vec3(.12,.42,.38)*depth*.6+spec*vec3(1.)+vec3(.18,.45,.4)*fres;
  c+=vec3(.14,.48,.42)*(1.-smoothstep(th*.9,th*1.4,f));
  c+=flashC;
  
  gl_FragColor=vec4(c,1.);
}`;

function makeShader(t,s){const sh=gl.createShader(t);gl.shaderSource(sh,s);gl.compileShader(sh);if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS))console.error(gl.getShaderInfoLog(sh));return sh;}
const prog=gl.createProgram();
gl.attachShader(prog,makeShader(gl.VERTEX_SHADER,vs));
gl.attachShader(prog,makeShader(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);gl.useProgram(prog);

const buf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
const aP=gl.getAttribLocation(prog,'p');gl.enableVertexAttribArray(aP);gl.vertexAttribPointer(aP,2,gl.FLOAT,false,0,0);

const uTime=gl.getUniformLocation(prog,'time');
const uRes=gl.getUniformLocation(prog,'res');
const uParts=gl.getUniformLocation(prog,'parts');
const uFlash=gl.getUniformLocation(prog,'flash');

let last=performance.now(),start=last;
function render(){
  const now=performance.now();
  physics((now-last)/1000);
  last=now;
  
  const pd=new Float32Array(NUM_P*3);
  for(let i=0;i<NUM_P;i++){pd[i*3]=particles[i].x;pd[i*3+1]=particles[i].y;pd[i*3+2]=particles[i].r;}
  
  const fd=new Float32Array(24);
  for(let i=0;i<Math.min(8,snapFlashes.length);i++){
    fd[i*3]=snapFlashes[i].x;fd[i*3+1]=snapFlashes[i].y;fd[i*3+2]=1-(now-snapFlashes[i].t)/300;
  }
  
  gl.uniform1f(uTime,(now-start)/1000);
  gl.uniform2f(uRes,canvas.width,canvas.height);
  gl.uniform3fv(uParts,pd);
  gl.uniform3fv(uFlash,fd);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
